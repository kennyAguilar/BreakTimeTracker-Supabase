"""
Utilidades para parsing de tarjetas de banda magn√©tica
=====================================================

Este m√≥dulo contiene todas las funciones necesarias para parsear datos de tarjetas
de banda magn√©tica en diferentes formatos. Incluye validaci√≥n, limpieza y extracci√≥n
de informaci√≥n √∫til para el sistema de control de descansos.

Caracter√≠sticas:
- Soporte para m√∫ltiples formatos de tarjeta
- Limpieza autom√°tica de caracteres especiales
- Validaci√≥n de formato
- Extracci√≥n de c√≥digos de empleado
- Logging detallado para debugging

Autor: Sistema BreakTimeTracker
Fecha: Julio 2025
"""

import re
import logging
from typing import Optional, Dict, Any


def parse_card_data(raw_data: str) -> str:
    """
    Parsea datos de tarjeta de banda magn√©tica y extrae informaci√≥n √∫til.
    
    Esta funci√≥n maneja m√∫ltiples formatos de tarjetas de banda magn√©tica:
    - Formato Track 1: %B + datos + ?
    - Formato Track 2: ; + datos + ?
    - Formato mixto con m√∫ltiples tracks
    - Datos num√©ricos puros
    
    Args:
        raw_data (str): Datos crudos de la tarjeta le√≠da por el lector
        
    Returns:
        str: C√≥digo limpio extra√≠do de la tarjeta
        
    Examples:
        >>> parse_card_data("%B123456789^DOE/JOHN^2512101?")
        "123456789"
        
        >>> parse_card_data(";123456789=2512101?")
        "123456789"
        
        >>> parse_card_data("123456789")
        "123456789"
    """
    if not raw_data:
        return ""
    
    # Log de entrada para debugging
    print(f"üîç parse_card_data - Entrada: '{raw_data}'")
    
    # Limpiar espacios en blanco al inicio y final
    cleaned_data = raw_data.strip()
    
    # Si est√° vac√≠o despu√©s de limpiar, retornar vac√≠o
    if not cleaned_data:
        print(f"‚ö†Ô∏è parse_card_data - Datos vac√≠os despu√©s de limpiar")
        return ""
    
    # Intentar diferentes patrones de parsing
    result = None
    
    # Patr√≥n 1: Track 1 (%B...^...^...?)
    track1_match = re.search(r'%B(\d+)\^', cleaned_data)
    if track1_match:
        result = track1_match.group(1)
        print(f"‚úÖ parse_card_data - Patr√≥n Track 1 encontrado: '{result}'")
        return result
    
    # Patr√≥n 2: Track 2 (;...=...?)
    track2_match = re.search(r';(\d+)=', cleaned_data)
    if track2_match:
        result = track2_match.group(1)
        print(f"‚úÖ parse_card_data - Patr√≥n Track 2 encontrado: '{result}'")
        return result
    
    # Patr√≥n 3: Secuencia num√©rica larga (m√°s de 6 d√≠gitos)
    numeric_match = re.search(r'\d{6,}', cleaned_data)
    if numeric_match:
        result = numeric_match.group(0)
        print(f"‚úÖ parse_card_data - Secuencia num√©rica encontrada: '{result}'")
        return result
    
    # Patr√≥n 4: Limpiar caracteres especiales y quedarse con alfanum√©ricos
    alphanumeric_only = re.sub(r'[^a-zA-Z0-9]', '', cleaned_data)
    if alphanumeric_only and len(alphanumeric_only) >= 3:
        result = alphanumeric_only
        print(f"‚úÖ parse_card_data - Datos alfanum√©ricos limpiados: '{result}'")
        return result
    
    # Si no se encontr√≥ ning√∫n patr√≥n conocido, retornar datos originales limpiados
    print(f"‚ö†Ô∏è parse_card_data - No se encontr√≥ patr√≥n conocido, retornando datos originales")
    return cleaned_data


def validate_card_format(card_data: str) -> bool:
    """
    Valida si los datos de la tarjeta tienen un formato v√°lido.
    
    Args:
        card_data (str): Datos de la tarjeta a validar
        
    Returns:
        bool: True si el formato es v√°lido, False en caso contrario
        
    Examples:
        >>> validate_card_format("123456789")
        True
        
        >>> validate_card_format("abc")
        False
        
        >>> validate_card_format("")
        False
    """
    if not card_data:
        return False
    
    # Debe tener al menos 3 caracteres
    if len(card_data) < 3:
        return False
    
    # Debe contener al menos algunos caracteres alfanum√©ricos
    if not re.search(r'[a-zA-Z0-9]', card_data):
        return False
    
    # No debe ser solo caracteres especiales
    if re.match(r'^[^a-zA-Z0-9]+$', card_data):
        return False
    
    return True


def get_card_info(raw_data: str) -> Dict[str, Any]:
    """
    Extrae informaci√≥n completa de una tarjeta de banda magn√©tica.
    
    Args:
        raw_data (str): Datos crudos de la tarjeta
        
    Returns:
        Dict[str, Any]: Diccionario con informaci√≥n extra√≠da:
            - parsed_code: C√≥digo limpio extra√≠do
            - is_valid: Si el formato es v√°lido
            - track_info: Informaci√≥n sobre el track detectado
            - raw_length: Longitud de los datos originales
            - clean_length: Longitud de los datos limpios
            
    Examples:
        >>> get_card_info("%B123456789^DOE/JOHN^2512101?")
        {
            'parsed_code': '123456789',
            'is_valid': True,
            'track_info': 'Track 1',
            'raw_length': 28,
            'clean_length': 9
        }
    """
    if not raw_data:
        return {
            'parsed_code': '',
            'is_valid': False,
            'track_info': 'No data',
            'raw_length': 0,
            'clean_length': 0,
            'error': 'No data provided'
        }
    
    # Parsear el c√≥digo
    parsed_code = parse_card_data(raw_data)
    
    # Validar formato
    is_valid = validate_card_format(parsed_code)
    
    # Detectar tipo de track
    track_info = 'Unknown'
    if '%B' in raw_data and '^' in raw_data:
        track_info = 'Track 1 (ISO/IEC 7813)'
    elif ';' in raw_data and '=' in raw_data:
        track_info = 'Track 2 (ISO/IEC 7813)'
    elif re.match(r'^\d+$', raw_data.strip()):
        track_info = 'Numeric only'
    elif re.search(r'\d{6,}', raw_data):
        track_info = 'Contains long numeric sequence'
    else:
        track_info = 'Custom format'
    
    return {
        'parsed_code': parsed_code,
        'is_valid': is_valid,
        'track_info': track_info,
        'raw_length': len(raw_data),
        'clean_length': len(parsed_code),
        'has_track1': '%B' in raw_data,
        'has_track2': ';' in raw_data,
        'numeric_sequences': re.findall(r'\d{3,}', raw_data),
        'special_chars': len(re.findall(r'[^a-zA-Z0-9]', raw_data))
    }


def extract_employee_code(card_data: str, fallback_patterns: Optional[list] = None) -> str:
    """
    Extrae espec√≠ficamente el c√≥digo de empleado de los datos de la tarjeta.
    
    Esta funci√≥n est√° optimizada para extraer c√≥digos de empleado usando
    patrones espec√≠ficos de la organizaci√≥n.
    
    Args:
        card_data (str): Datos de la tarjeta
        fallback_patterns (list, optional): Patrones adicionales a probar
        
    Returns:
        str: C√≥digo de empleado extra√≠do
        
    Examples:
        >>> extract_employee_code("EMPL123456")
        "123456"
        
        >>> extract_employee_code("E123456789")
        "123456789"
    """
    if not card_data:
        return ""
    
    # Primero usar el parser general
    general_parsed = parse_card_data(card_data)
    
    # Patrones espec√≠ficos para c√≥digos de empleado
    employee_patterns = [
        r'EMPL(\d+)',           # EMPL123456
        r'EMP(\d+)',            # EMP123456
        r'E(\d{6,})',           # E123456789
        r'ID(\d+)',             # ID123456
        r'USER(\d+)',           # USER123456
        r'CARD(\d+)',           # CARD123456
    ]
    
    # Agregar patrones adicionales si se proporcionan
    if fallback_patterns:
        employee_patterns.extend(fallback_patterns)
    
    # Probar patrones espec√≠ficos
    for pattern in employee_patterns:
        match = re.search(pattern, card_data.upper())
        if match:
            result = match.group(1)
            print(f"‚úÖ extract_employee_code - Patr√≥n '{pattern}' encontrado: '{result}'")
            return result
    
    # Si no se encontr√≥ patr√≥n espec√≠fico, usar resultado general
    print(f"‚ÑπÔ∏è extract_employee_code - Usando parser general: '{general_parsed}'")
    return general_parsed


def clean_card_data(raw_data: str) -> str:
    """
    Limpia los datos de la tarjeta eliminando caracteres problem√°ticos.
    
    Args:
        raw_data (str): Datos crudos de la tarjeta
        
    Returns:
        str: Datos limpios
        
    Examples:
        >>> clean_card_data("  %B123^DOE?  ")
        "%B123^DOE?"
        
        >>> clean_card_data("123\n456\r789")
        "123456789"
    """
    if not raw_data:
        return ""
    
    # Eliminar espacios en blanco al inicio y final
    cleaned = raw_data.strip()
    
    # Eliminar saltos de l√≠nea y retornos de carro
    cleaned = re.sub(r'[\r\n\t]', '', cleaned)
    
    # Eliminar caracteres de control (excepto los espec√≠ficos de banda magn√©tica)
    cleaned = re.sub(r'[\x00-\x1F\x7F-\x9F]', '', cleaned)
    
    return cleaned


def is_magnetic_stripe_format(data: str) -> bool:
    """
    Determina si los datos corresponden a una tarjeta de banda magn√©tica.
    
    Args:
        data (str): Datos a verificar
        
    Returns:
        bool: True si parece ser formato de banda magn√©tica
        
    Examples:
        >>> is_magnetic_stripe_format("%B123456789^DOE/JOHN^2512101?")
        True
        
        >>> is_magnetic_stripe_format("123456789")
        False
    """
    if not data:
        return False
    
    # Indicadores de formato de banda magn√©tica
    magnetic_indicators = [
        r'%[A-Z]',          # Inicio de Track 1
        r';\d+=',           # Patr√≥n de Track 2
        r'\^[A-Z/\s]+\^',   # Nombre en Track 1
        r'=\d{4}',          # Fecha de expiraci√≥n en Track 2
        r'\?\s*$',          # Terminador de track
    ]
    
    # Verificar si coincide con alg√∫n indicador
    for pattern in magnetic_indicators:
        if re.search(pattern, data):
            return True
    
    return False


def debug_card_parsing(raw_data: str) -> Dict[str, Any]:
    """
    Funci√≥n de debugging para analizar el parsing de tarjetas.
    
    Args:
        raw_data (str): Datos crudos de la tarjeta
        
    Returns:
        Dict[str, Any]: Informaci√≥n detallada de debugging
    """
    print(f"\nüîç === DEBUG CARD PARSING ===")
    print(f"üì• Datos de entrada: '{raw_data}'")
    print(f"üìè Longitud: {len(raw_data)} caracteres")
    
    # Informaci√≥n b√°sica
    debug_info = {
        'raw_data': raw_data,
        'raw_length': len(raw_data),
        'is_empty': not bool(raw_data),
        'has_whitespace': bool(re.search(r'\s', raw_data)) if raw_data else False,
        'has_special_chars': bool(re.search(r'[^a-zA-Z0-9]', raw_data)) if raw_data else False,
    }
    
    if not raw_data:
        print(f"‚ùå Datos vac√≠os")
        return debug_info
    
    # An√°lisis de caracteres
    print(f"üî§ An√°lisis de caracteres:")
    print(f"   - Contiene espacios: {debug_info['has_whitespace']}")
    print(f"   - Contiene caracteres especiales: {debug_info['has_special_chars']}")
    print(f"   - Caracteres √∫nicos: {len(set(raw_data))}")
    
    # Verificar formato de banda magn√©tica
    is_magnetic = is_magnetic_stripe_format(raw_data)
    debug_info['is_magnetic_stripe'] = is_magnetic
    print(f"üß≤ Es formato de banda magn√©tica: {is_magnetic}")
    
    # Probar parsing
    try:
        parsed_result = parse_card_data(raw_data)
        debug_info['parsed_result'] = parsed_result
        debug_info['parsing_success'] = True
        print(f"‚úÖ Resultado del parsing: '{parsed_result}'")
    except Exception as e:
        debug_info['parsed_result'] = ""
        debug_info['parsing_success'] = False
        debug_info['parsing_error'] = str(e)
        print(f"‚ùå Error en parsing: {e}")
    
    # Obtener informaci√≥n completa
    try:
        card_info = get_card_info(raw_data)
        debug_info['card_info'] = card_info
        print(f"üìä Informaci√≥n de tarjeta: {card_info}")
    except Exception as e:
        debug_info['card_info_error'] = str(e)
        print(f"‚ùå Error obteniendo info de tarjeta: {e}")
    
    print(f"üîç === FIN DEBUG ===\n")
    return debug_info


# Funci√≥n de prueba para verificar el m√≥dulo
def test_card_parsing():
    """
    Funci√≥n de prueba para verificar el funcionamiento del m√≥dulo.
    """
    print("üß™ === PRUEBAS DE PARSING DE TARJETAS ===\n")
    
    # Casos de prueba
    test_cases = [
        # Formato Track 1
        "%B123456789^DOE/JOHN^2512101?",
        "%B4111111111111111^DOE/JANE^25121015432112345678?",
        
        # Formato Track 2
        ";123456789=2512101?",
        ";4111111111111111=25121015432112345678?",
        
        # Formato mixto
        "%B123456789^DOE/JOHN^2512101?;123456789=2512101?",
        
        # Num√©rico puro
        "123456789",
        "4111111111111111",
        
        # Datos con prefijos
        "EMPL123456",
        "E123456789",
        "ID987654321",
        
        # Datos problem√°ticos
        "  123456789  ",
        "123\n456\r789",
        "abc123def456",
        "",
        "!@#$%^&*()",
    ]
    
    for i, test_data in enumerate(test_cases, 1):
        print(f"üìã Prueba {i}: '{test_data}'")
        
        try:
            # Parsing b√°sico
            result = parse_card_data(test_data)
            print(f"   ‚úÖ Resultado: '{result}'")
            
            # Validaci√≥n
            is_valid = validate_card_format(result)
            print(f"   üìä V√°lido: {is_valid}")
            
            # Informaci√≥n completa
            card_info = get_card_info(test_data)
            print(f"   üìÑ Tipo: {card_info['track_info']}")
            
        except Exception as e:
            print(f"   ‚ùå Error: {e}")
        
        print()
    
    print("üß™ === FIN PRUEBAS ===\n")


# Ejecutar pruebas si el m√≥dulo se ejecuta directamente
if __name__ == "__main__":
    test_card_parsing()
